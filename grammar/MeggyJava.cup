// CUP specification for a simple expression evaluator (w/ actions)
package mahimahi.parser;
import mahimahi.parser.*;
import mahimahi.util.TextFromJar;
import java_cup.runtime.*;
import java.util.*;
import java.io.PrintWriter;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;

/* Preliminaries to set up and use the scanner.  */
parser code {:  
             public PrintWriter out;
	     public String programName;

       	     public void unrecovered_syntax_error(Symbol cur_SymbolValue) {
               report_fatal_error("Fatal syntax error", cur_SymbolValue);
             }

	     public void report_fatal_error(String message, Object info) {
               Symbol symbolValue = (Symbol)info;
	       SymbolValue tok = (SymbolValue)symbolValue.value;

               report_error(message, info); done_parsing();
               throw new ParseException("Fatal parsing error", tok.line, tok.pos);
             }
       
             public void report_error(String message, Object info) {
	       Symbol symbolValue = (Symbol) info;
	       SymbolValue tok = (SymbolValue) symbolValue.value;
	       System.err.println("[" + tok.line + "," + tok.pos + "]" + message + " at " + tok.toString() );
             }            
       
             :}

action code {: private PrintStream sout; :}

/*********** Terminals (tokens returned by the scanner). ***********/
/* operators */
terminal  SymbolValue            PLUS, MINUS, TIMES, ASSIGN, EQUAL, AND, LT, NOT, COMMA, DOT;
terminal  SymbolValue            LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, SEMI;

/* types */
terminal  SymbolValue            BOOLEAN, INT, BYTE, STRING_TYPE, VOID, COLOR, BUTTON, TONE;

terminal  SymbolValue            IDENTIFIER;

/* keywords */
terminal  SymbolValue            MAIN, IF, ELSE, WHILE, PUBLIC, RETURN, STATIC, THIS, CLASS, EXTENDS, NEW;

/* constants */
terminal  SymbolValue    INT_LITERAL;
terminal  SymbolValue    COLOR_LITERAL;
terminal  SymbolValue    BUTTON_LITERAL;
terminal  Symbolvalue    STRING_LITERAL;
terminal  SymbolValue    TONE_LITERAL;
terminal  SymbolValue    TRUE, FALSE;

/* others */
terminal  SymbolValue    IMPORT, MEGGY;
terminal  SymbolValue    MEGGYSETPIXEL, MEGGYSETAUXLEDS, 
	                 MEGGYTONESTART, MEGGYDELAY, MEGGYGETPIXEL, MEGGYCHECKBUTTON;


/*********** Non-terminals ***********/
non terminal               Goal, MainClass, Statement_list, Statement, Empty;
non terminal  SymbolValue  Expression;

/* Precedences */
precedence left  ASSIGN;
precedence left  PLUS;
precedence left  TIMES;
precedence left  EQUAL, AND, LT;
precedence right NOT, MINUS ;
precedence left  DOT;

/* The grammar */
start with Goal;

Goal   ::=     IMPORT MEGGY SEMI 
               MainClass 
               ;

MainClass ::=  CLASS IDENTIFIER:id 
{: List<String> prolog;

 sout = new PrintStream(new FileOutputStream(id.lexeme + ".java.s")); 
 parser.out = new PrintWriter(sout);
 /* Loading prolog snippet */
 prolog = TextFromJar.readTextFromJar("avrH.rtl.s");
 for(String proline: prolog)
     parser.out.println(proline);
 :}
               LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING_TYPE LBRACKET RBRACKET IDENTIFIER RPAREN
               LBRACE Statement_list RBRACE RBRACE
	       {: parser.out.flush(); :};

Statement_list ::= Statement Statement_list
		   |
		   Empty;

Statement ::=  MEGGYSETPIXEL LPAREN Expression:e0 
{:  parser.out.println("ldi r24, lo8("+e0.lexeme+")"); :}
               COMMA Expression:e1 
{:  parser.out.println("ldi r22, lo8("+e1.lexeme+")"); :}
               COMMA Expression:e2 
{:  parser.out.println("ldi r20, lo8("+e2.lexeme+")"); :}
               RPAREN SEMI
{:  
   /* At this point, arguments should already be loaded */ 
 parser.out.println("call _Z6DrawPxhhh");
 parser.out.println("call _Z12DisplaySlatev");
 :}
               ;

Expression ::= LPAREN BYTE RPAREN Expression:e  {: RESULT = e; :}
               |
               INT_LITERAL:e  {: RESULT = e; :}
               |
               COLOR_LITERAL:e {: RESULT = e;  :};

Empty ::= ;